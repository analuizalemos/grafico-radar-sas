<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Estes scripts serão carregados no SAS VA. Eles resultarão num erro 404 (inofensivo) ao testar localmente. -->
  <script type="text/javascript" src="../../util/messagingUtil.js"></script>
  <script type="text/javascript" src="../../util/contentUtil.js"></script>
</head>
<body>

<div id="tooltip" class="d3-tip" style="position: absolute; opacity: 0; pointer-events: none;"></div>

<style type="text/css">
  html, body, svg {
    overflow: hidden;
    margin: 0px;
    width: 100%;
    height: 100%;
  }

  text {
    font-family: Verdana, sans-serif;
  }

  .legend-title {
    font-size: .9em;
    font-weight: bold;
    text-anchor: middle;
    dominant-baseline: hanging;
  }

  .legend-text {
    font-size: .8em;
    dominant-baseline: central;
  }

  .legend-rect {
    stroke-width: 1;
  }

  .g-legend-entry {
    cursor: pointer;
  }

  .g-legend-entry.selected .legend-text {
    font-weight: bold;
  }

  .g-legend-entry.selected .legend-rect {
    stroke-width: 2px;
  }

  .data-path {
    pointer-events: none;
    stroke-width: 2;
  }

  .measure-label {
    font-size: .8em;
    dominant-baseline: hanging;
  }

  /* Estilos para o Tooltip */
  .d3-tip {
    background: white;
    padding: 6px;
    border: 1px solid #C4C4C4;
    border-radius: 2px;
    z-index: 10;
  }

  .d3-tip-content {
    white-space: nowrap;
    font-family: Verdana, sans-serif;
    font-size: .9em;
    text-align: left;
  }
</style>

<script type="module">
"use strict";

// Importa D3.js v7 via CDN como um módulo ES
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

/******************************************************* Declare variables *******************************************************/

const SVG_ID = "radar"; 
const SAMPLE_MESSAGE = {
  version: "1",
  resultName: "dd55",
  rowCount: 18,
  availableRowCount: 18,
  data: [
    ["Hybrid", "Cylinders", 3.66, "BEST12.2"],["Hybrid", "MPG (City)", 55, "BEST12.2"],["Hybrid", "MSRP", 19920, "DOLLAR12.2"],
    ["Sedan", "Cylinders", 5.58, "BEST12.2"],["Sedan", "MPG (City)", 21.08, "BEST12.2"],["Sedan", "MSRP", 29773.61, "DOLLAR12.2"],
    ["Sports", "Cylinders", 6.34, "BEST12.2"],["Sports", "MPG (City)", 18.40, "BEST12.2"],["Sports", "MSRP", 53387.06, "DOLLAR12.2"],
    ["SUV", "Cylinders", 6.56, "BEST12.2"],["SUV", "MPG (City)", 16.1, "BEST12.2"],["SUV", "MSRP", 34790.25, "DOLLAR12.2"],
    ["Truck", "Cylinders", 6.25, "BEST12.2"],["Truck", "MPG (City)", 16.5, "BEST12.2"],["Truck", "MSRP", 24941.37, "DOLLAR12.2"],
    ["Wagon", "Cylinders", 5.3, "BEST12.2"],["Wagon", "MPG (City)", 21.1, "BEST12.2"],["Wagon", "MSRP", 28840.53, "DOLLAR12.2"]
  ],
  columns: [
    { name: "bi173", label: "Type", type: "string" }, { name: "bi174", label: "Metric", type: "string" },
    { name: "bi175", label: "Measure", type: "number"}, { name: "bi176", label: "Format", type: "string" }
  ]
};
const OPACITY = {
  fill: { focus: 0.6, default: 0.2, unfocus: 0.1 },
  stroke: { focus: 1, default: 0.6, unfocus: 0.2 }
}; 

let VA_MESSAGE, VA_RESULT_NAME, DATA, OLD_DATA, METADATA = [], OLD_METADATA, SELECTED_CATEGORY;
let LAST_TRANSITION_END = Date.now(); 

const TRANS_TIME = 500, TRANS_DELAY = 20, HOVER_TRANS_TIME = 100, ENTER_REMOVE_TRANS_TIME = 200, MEASURE_LABEL_PADDING = 10;
let WIDTH, HEIGHT, RADIUS, OLD_RADIUS, DELTA_ANGLE, TOP_PAD, SIDE_PAD;

const SCALED_FORMAT = d3.format("3.0f"); 
d3.selection.prototype.moveToFront = function() { return this.each(function() { this.parentNode.appendChild(this); }); };
let SVG, G_CHART_AREA, G_GRID, GRID_LINES, GRID_CIRCLES, MEASURE_LABELS, DATA_PATHS, DATA_POINTS;

const LEG = {
  topPad: 20, titlePad: 5, rowPad: 3, rectWidth: 12, rectPad: 5, textPad: 5,
  title: undefined, data: undefined, elPos: undefined, height: undefined,
  groupSelection: undefined, titleDataJoin: undefined, groupDataJoin: undefined
};

const TOOLTIP = d3.select("#tooltip");

const GRAD = {
  fill: {},
  stroke: {},
  fillScale: d3.scaleOrdinal(d3.schemeCategory10),
  strokeScale: d3.scaleOrdinal(d3.schemeDark2),
  data: undefined, defsSelection: undefined, gradsDataJoin: undefined
};


/*************************************************** Setup and Env Detection ***************************************************/
if (typeof va === 'undefined') {
  console.log("Ambiente SAS VA não detetado. A executar em modo de teste local com dados de exemplo.");
  window.va = {
    messagingUtil: {
      setOnDataReceivedCallback: function(callback) {
        callback(SAMPLE_MESSAGE);
      },
      postInstructionalMessage: function(msg) {
        console.warn("Mensagem de Instrução para o SAS:", msg);
      }
    },
    contentUtil: {
      setupResizeListener: function(callback) {
        window.addEventListener('resize', callback);
      },
      validateRoles: function() {
        return true;
      }
    }
  };
}

va.messagingUtil.setOnDataReceivedCallback(handleCallback);
va.contentUtil.setupResizeListener(drawElements);


/****************************************************** Callback Functions ******************************************************/
function handleCallback(messageFromVA) {
  if (LAST_TRANSITION_END > Date.now()) {
    setTimeout(() => onDataReceived(messageFromVA), LAST_TRANSITION_END - Date.now());
    LAST_TRANSITION_END += TRANS_TIME + TRANS_DELAY;
  } else {
    onDataReceived(messageFromVA);
    LAST_TRANSITION_END = Date.now() + TRANS_TIME + TRANS_DELAY;
  }
}

function onDataReceived(messageFromVA) {
  try {
    if (!messageFromVA || !messageFromVA.data || messageFromVA.data.length === 0) {
      d3.select("#" + SVG_ID).remove();
      return;
    }

    VA_MESSAGE = messageFromVA;
    VA_RESULT_NAME = messageFromVA.resultName;

    if (!va.contentUtil.validateRoles(messageFromVA, ["string", "string", "number", "string"], ["number"])) {
      va.messagingUtil.postInstructionalMessage(VA_RESULT_NAME, "D3 Radar Chart expects columns to be assigned in this order:\n 1. Category (string)\n 2. Metric Name (string)\n 3. Metric Value (number)\n 4. Metric Format (string)");
      return;
    }
    
    const nestedData = Array.from(d3.group(VA_MESSAGE.data, d => d[1]), ([key, values]) => ({ key, values }));
    const numMeasures = nestedData.length;

    if (numMeasures === 0) {
        d3.select("#" + SVG_ID).remove();
        return;
    }

    OLD_METADATA = METADATA;
    DELTA_ANGLE = (2 * Math.PI) / numMeasures;
    METADATA = { category: VA_MESSAGE.columns[0].label, metrics: {} };
    for (let i = 0; i < numMeasures; i++) {
      const key = nestedData[i].key;
      const formatValue = (nestedData[i].values && nestedData[i].values[0]) ? nestedData[i].values[0][3] : "";
      const maxValue = d3.max(VA_MESSAGE.data, d => (d[1] === key ? d[2] : -Infinity));
      
      METADATA.metrics[key] = {
        metric: key,
        angle: i * DELTA_ANGLE,
        format: translateFormat(formatValue),
        maximum: maxValue
      };
    }

    OLD_DATA = DATA;
    DATA = [];
    const categories = Array.from(d3.group(VA_MESSAGE.data, d => d[0]).keys());
    
    categories.forEach(categoryValue => {
        let datum = {
            category: categoryValue,
            id: "id-" + String(categoryValue).replace(/[\W]/g, "_"),
            metrics: []
        };
        
        Object.keys(METADATA.metrics).forEach(metricName => {
            const metricData = VA_MESSAGE.data.find(d => d[0] === categoryValue && d[1] === metricName);
            let measure = 0;
            let scaledMeasure = 0;
            if (metricData && metricData[2] != null) {
                measure = metricData[2];
                const maxVal = METADATA.metrics[metricName].maximum;
                if (maxVal > 0) {
                    scaledMeasure = measure / maxVal;
                }
            }
            datum.metrics.push({
                metric: metricName,
                measure: measure,
                scaledMeasure: scaledMeasure
            });
        });
        DATA.push(datum);
    });

    LEG.title = METADATA.category;
    LEG.data = DATA.map(d => ({ key: d.category, id: d.id }));
    GRAD.data = LEG.data;

    if (d3.select("#" + SVG_ID).empty()) {
      drawElements();
    } else {
      updateElements();
    }
  } catch (error) {
    console.error("Error processing data in onDataReceived:", error);
    if (VA_RESULT_NAME && va && va.messagingUtil) {
      va.messagingUtil.postInstructionalMessage(VA_RESULT_NAME, "An error occurred: " + error.message);
    }
  }
}

function drawElements() {
  if (!DATA) return;
  d3.select("#" + SVG_ID).remove();
  WIDTH = document.body.clientWidth;
  HEIGHT = document.body.clientHeight;

  SVG = d3.select("body").append("svg").attr("id", SVG_ID).attr("width", WIDTH).attr("height", HEIGHT).on("click", legendDeselectAll);
  SVG.append("defs").classed("gradient-defs", true);
  GRAD.defsSelection = SVG.select(".gradient-defs");
  defineGradients();
  calculatePadding();
  calculateLegendDimensions();
  drawLegend();
  OLD_RADIUS = RADIUS;
  RADIUS = Math.max(Math.min(WIDTH - 2 * SIDE_PAD, HEIGHT - LEG.height - 2 * TOP_PAD) / 2, 0);
  G_CHART_AREA = SVG.append("g").classed("g-chart-area", true).attr("transform", "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")");
  G_GRID = G_CHART_AREA.append("g").classed("g-grid", true);

  GRID_LINES = G_GRID.selectAll(".grid-line").data(Object.values(METADATA.metrics), d => d.metric);
  GRID_LINES.enter().append("line").classed("grid-line", true).attr("stroke", "#C4C4C4").attr("data-angle", d => d.angle).attr("x1", 0).attr("y1", 0).merge(GRID_LINES).attr("x2", d => RADIUS * Math.sin(d.angle)).attr("y2", d => -RADIUS * Math.cos(d.angle));

  GRID_CIRCLES = G_GRID.selectAll(".grid-circle").data([0.2, 0.4, 0.6, 0.8, 1]);
  GRID_CIRCLES.enter().append("circle").classed("grid-circle", true).attr("fill", "none").attr("stroke", "#E4E4E4").attr("cx", 0).attr("cy", 0).merge(GRID_CIRCLES).attr("r", d => d * RADIUS);

  MEASURE_LABELS = G_CHART_AREA.selectAll(".measure-label").data(Object.values(METADATA.metrics), d => d.metric);
  MEASURE_LABELS.enter().append("text").classed("measure-label", true).text(d => d.metric).attr("data-angle", d => d.angle)
    .attr("dx", function(d) { return (d.angle == 0 || d.angle == Math.PI) ? -this.getBBox().width / 2 + "px" : (d.angle > 0 && d.angle < Math.PI) ? "0px" : -this.getBBox().width + "px"; })
    .attr("dy", function(d) { return d.angle == Math.PI / 2 || d.angle == 3 * Math.PI / 2 ? -this.getBBox().height / 2 + "px" : (d.angle > Math.PI / 2 && d.angle < 3 * Math.PI / 2) ? "0px" : -this.getBBox().height + "px"; })
    .merge(MEASURE_LABELS).attr("x", d => (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle)).attr("y", d => -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle));

  DATA_PATHS = G_CHART_AREA.selectAll(".data-path").data(DATA, d => d.id);
  DATA_PATHS.enter().append("path").classed("data-path", true).attr("id", d => "path-" + d.id)
    .attr("fill", d => GRAD.fill[d.category] ? GRAD.fill[d.category] : GRAD.fillScale(d.category))
    .attr("fill-opacity", d => getOpacity(d.category, OPACITY.fill))
    .attr("stroke", d => GRAD.stroke[d.category] ? GRAD.stroke[d.category] : GRAD.strokeScale(d.category))
    .attr("stroke-opacity", d => getOpacity(d.category, OPACITY.stroke))
    .merge(DATA_PATHS).attr("d", getPath);
}

function getPath(dPath) {
  const points = [];
  let path = "M ";
  const metricsOrder = Object.keys(METADATA.metrics);
  for (let j = 0; j < metricsOrder.length; j++) {
    const metricName = metricsOrder[j];
    const metricData = dPath.metrics.find(m => m.metric === metricName);
    const scaledValue = metricData ? metricData.scaledMeasure : 0;
    const angle = METADATA.metrics[metricName].angle;

    const x = RADIUS * scaledValue * Math.sin(angle);
    const y = -RADIUS * scaledValue * Math.cos(angle);
    points.push({ category: dPath.category, id: dPath.id, ...metricData, x: x, y: y });
    path += `${x},${y}${j === metricsOrder.length - 1 ? " Z" : " L "}`;
  }

  G_CHART_AREA.selectAll(".data-point-" + dPath.id).remove();
  DATA_POINTS = G_CHART_AREA.selectAll(".data-point-" + dPath.id).data(points, d => d.metric);

  DATA_POINTS.enter().append("circle").attr("class", "data-point-" + dPath.id)
    .attr("fill", GRAD.fill[dPath.category] ? GRAD.fill[dPath.category] : GRAD.fillScale(dPath.category))
    .attr("fill-opacity", getOpacity(dPath.category, OPACITY.stroke))
    .on("mouseover", (event, d) => {
      TOOLTIP.style("opacity", 1)
        .html(`<table class='d3-tip-content'><tr><td>${METADATA.category}:\t</td><td>${d.category}</td></tr><tr><td>${d.metric}:\t</td><td>${METADATA.metrics[d.metric].format(d.measure)}</td></tr><tr><td>${d.metric} Scaled:\t</td><td>${SCALED_FORMAT(d.scaledMeasure * 100)}</td></tr></table>`);
    })
    .on("mousemove", (event) => TOOLTIP.style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px"))
    .on("mouseout", () => TOOLTIP.style("opacity", 0))
    .merge(DATA_POINTS).attr("cx", d => d.x).attr("cy", d => d.y).attr("r", 4);

  return path;
}

function updateElements() {
    if (!DATA) return;
    WIDTH = document.body.clientWidth;
    HEIGHT = document.body.clientHeight;
    SVG.attr("width", WIDTH).attr("height", HEIGHT);
    
    calculatePadding(); defineGradients(); calculateLegendDimensions(); updateLegend();
    
    OLD_RADIUS = RADIUS;
    RADIUS = Math.max(Math.min(WIDTH - 2 * SIDE_PAD, HEIGHT - LEG.height - 2 * TOP_PAD) / 2, 0);

    G_CHART_AREA.transition().duration(TRANS_TIME).attr("transform", "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")");

    GRID_LINES = G_GRID.selectAll(".grid-line").data(Object.values(METADATA.metrics), d => d.metric);
    GRID_LINES.transition().duration(TRANS_TIME).attr("x2", d => RADIUS * Math.sin(d.angle)).attr("y2", d => -RADIUS * Math.cos(d.angle));
    GRID_LINES.enter().append("line").classed("grid-line", true).attr("stroke", "#C4C4C4").attr("data-angle", d => d.angle).attr("x1", 0).attr("y1", 0).attr("x2", d => RADIUS * Math.sin(d.angle)).attr("y2", d => -RADIUS * Math.cos(d.angle)).style("opacity", 0).transition().delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME).duration(ENTER_REMOVE_TRANS_TIME).style("opacity", 1);
    GRID_LINES.exit().transition().duration(ENTER_REMOVE_TRANS_TIME).style("opacity", 0).remove();

    GRID_CIRCLES = G_GRID.selectAll(".grid-circle").data([0.2,0.4,0.6,0.8,1]).transition().duration(TRANS_TIME).attr("r", d => d * RADIUS);

    MEASURE_LABELS = G_CHART_AREA.selectAll(".measure-label").data(Object.values(METADATA.metrics), d => d.metric);
    MEASURE_LABELS.transition().duration(TRANS_TIME)
      .attr("dx", function(d) { return (d.angle == 0 || d.angle == Math.PI) ? -this.getBBox().width / 2 + "px" : d.angle > 0 && d.angle < Math.PI ? "0px" : -this.getBBox().width + "px"; })
      .attr("dy", function(d) { return d.angle == Math.PI / 2 || d.angle == 3 * Math.PI / 2 ? -this.getBBox().height / 2 + "px" : d.angle > Math.PI / 2 && d.angle < 3 * Math.PI / 2 ? "0px" : -this.getBBox().height + "px"; })
      .attr("x", d => (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle))
      .attr("y", d => -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle));
    MEASURE_LABELS.enter().append("text").classed("measure-label", true).text(d => d.metric)
      .attr("dx", function(d) { return d.angle == 0 || d.angle == Math.PI ? -this.getBBox().width / 2 + "px" : d.angle > 0 && d.angle < Math.PI ? "0px" : -this.getBBox().width + "px"; })
      .attr("dy", function(d) { return d.angle == Math.PI / 2 || d.angle == 3 * Math.PI / 2 ? -this.getBBox().height / 2 + "px" : d.angle > Math.PI / 2 && d.angle < 3 * Math.PI / 2 ? "0px" : -this.getBBox().height + "px"; })
      .attr("x", d => (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle)).attr("y", d => -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle))
      .style("opacity", 0).transition().delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME).duration(ENTER_REMOVE_TRANS_TIME).style("opacity", 1);
    MEASURE_LABELS.exit().transition().duration(ENTER_REMOVE_TRANS_TIME).style("opacity", 0).remove();

    DATA_PATHS = G_CHART_AREA.selectAll(".data-path").data(DATA, d => d.id);
    DATA_PATHS.transition().duration(TRANS_TIME).attr("d", getPath);
    
    DATA_PATHS.enter().append("path").classed("data-path", true).attr("id", d => "path-" + d.id)
      .attr("fill", d => GRAD.stroke[d.category] ? GRAD.stroke[d.category] : GRAD.strokeScale(d.category))
      .attr("fill-opacity", d => getOpacity(d.category, OPACITY.fill))
      .attr("stroke", d => GRAD.stroke[d.category] ? GRAD.stroke[d.category] : GRAD.strokeScale(d.category))
      .attr("stroke-opacity", d => getOpacity(d.category, OPACITY.stroke))
      .attr("d", d => { let path = "M "; for (let j = 0; j < Object.keys(METADATA.metrics).length; j++) { path += "0,0" + (j == Object.keys(METADATA.metrics).length - 1 ? " Z" : " L "); } return path; })
      .style("opacity", 0).transition().duration(TRANS_TIME).style("opacity", 1).attr("d", getPath);

    DATA_PATHS.exit().each(function(d) { G_CHART_AREA.selectAll(".data-point-" + d.id).transition().duration(TRANS_TIME).attr("cx", 0).attr("cy", 0).style("opacity", 0).remove(); }).transition().duration(TRANS_TIME).attr("d", d => { let path = "M "; for (let j = 0; j < d.metrics.length; j++) { path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L "); } return path; }).style("opacity", 0).remove();
}

/******************************************************* Helper Functions *******************************************************/
function calculateLegendDimensions() {
  if (!SVG || !LEG.data || LEG.data.length === 0) { LEG.height = 0; return; }
  let titleHeight = 0;
  const tempTitle = SVG.append("text").classed("legend-title", true).text(LEG.title).style("opacity", 0);
  titleHeight = tempTitle.node().getBBox().height;
  tempTitle.remove();

  const textWidths = []; 
  let textHeight = 0;
  const tempText = SVG.append("text").classed("legend-text", true).style("font-weight", "bold").style("opacity", 0);
  LEG.data.forEach(d => {
    tempText.text(d.key);
    const box = tempText.node().getBBox();
    textHeight = Math.max(textHeight, box.height);
    textWidths.push(box.width);
  });
  tempText.remove();

  const rows = [], rowSums = []; let row = 0;
  for (let i = 0; i < textWidths.length; i++) {
    let rowSum = textWidths[i] + LEG.rectWidth + LEG.rectPad + LEG.textPad; rows.push(row);
    while (rowSum + textWidths[i + 1] + LEG.rectWidth + LEG.rectPad + LEG.textPad <= WIDTH && i + 1 < textWidths.length) { i++; rowSum += textWidths[i] + LEG.rectWidth + LEG.rectPad + LEG.textPad; rows.push(row); }
    rowSums.push(rowSum); row++;
  }
  LEG.elPos = [];
  for (let i = 0; i < textWidths.length; i++) { LEG.elPos.push({ x: (i == 0 || rows[i - 1] != rows[i]) ? WIDTH / 2 - rowSums[rows[i]] / 2 : LEG.elPos[i - 1].x + textWidths[i - 1] + LEG.rectWidth + LEG.rectPad + LEG.textPad, y: titleHeight + LEG.titlePad + rows[i] * (textHeight + LEG.rowPad) }); }
  LEG.height = LEG.elPos.length > 0 ? LEG.elPos[LEG.elPos.length - 1].y + textHeight + LEG.rowPad : 0;
}

function drawLegend() {
  if (!LEG.data || !SVG) return;
  SVG.selectAll(".g-legend").remove(); 
  LEG.groupSelection = SVG.append("g").classed("g-legend", true);
  LEG.groupSelection.append("text").classed("legend-title", true).text(LEG.title).attr("transform", `translate(${WIDTH/2}, 0)`);
  const entries = LEG.groupSelection.selectAll(".g-legend-entry").data(LEG.data, d => d.id);
  const enterEntries = entries.enter().append("g").classed("g-legend-entry", true).attr("id", d => `${d.id}-legend-entry`).on("click", (event, d) => legendSelect(event, d));
  enterEntries.append("rect").classed("legend-rect", true).attr("width", LEG.rectWidth).attr("height", LEG.rectWidth);
  enterEntries.append("text").classed("legend-text", true).attr("x", LEG.rectWidth + LEG.rectPad).attr("y", LEG.rectWidth / 2);

  const allEntries = enterEntries.merge(entries);
  allEntries.attr("transform", (d, i) => `translate(${LEG.elPos[i].x}, ${LEG.elPos[i].y})`);
  allEntries.select(".legend-rect").attr("fill", d => `url(#${d.id}-gradient)`).attr("stroke", d => GRAD.stroke[d.key] ? GRAD.stroke[d.key] : GRAD.strokeScale(d.key));
  allEntries.select(".legend-text").text(d => d.key);

  LEG.groupSelection.attr("transform", () => `translate(0, ${HEIGHT - LEG.height})`);
}

function updateLegend() {
  if (!LEG.data) return;
  drawLegend();
}

function defineGradients() {
  if (!GRAD.data) return;
  GRAD.defsSelection.selectAll(".gradient").remove();
  GRAD.gradsDataJoin = GRAD.defsSelection.selectAll(".gradient").data(GRAD.data, d => d.id);
  GRAD.gradsDataJoin.enter().append("linearGradient").classed("gradient", true).attr("id", d => `${d.id}-gradient`).attr("x1", "0%").attr("x2", "100%").attr("y1", "50%").attr("y2", "50%").each(function(d) {
    d3.select(this).append("stop").attr("class", "start").attr("offset", "0%").attr("stop-color", () => GRAD.fill[d.key] ? GRAD.fill[d.key] : GRAD.fillScale(d.key)).attr("stop-opacity", 1);
    d3.select(this).append("stop").attr("class", "end").attr("offset", "100%").attr("stop-color", () => GRAD.fill[d.key] ? GRAD.fill[d.key] : GRAD.fillScale(d.key)).attr("stop-opacity", 0.7);
  });
}

function calculatePadding() {
  if (!SVG || !METADATA.metrics || Object.keys(METADATA.metrics).length === 0) {
    TOP_PAD = 20; SIDE_PAD = 20; return;
  }
  let height = 12, width = 0;
  const tempText = SVG.append("text").classed("measure-label", true).style("opacity", 0);
  Object.values(METADATA.metrics).forEach(d => {
      tempText.text(d.metric);
      const box = tempText.node().getBBox();
      height = Math.max(height, box.height);
      width = Math.max(width, box.width);
  });
  tempText.remove();
  SIDE_PAD = width + 2 * MEASURE_LABEL_PADDING;
  TOP_PAD = height + 2 * MEASURE_LABEL_PADDING;
}

function getOpacity(category, opacity) { return SELECTED_CATEGORY ? (category == SELECTED_CATEGORY ? opacity.focus : opacity.unfocus) : opacity.default; }

function translateFormat(formatString) {
  if (!formatString) return d3.format("");
  if (formatString.indexOf(".") == formatString.length - 1) formatString += 0;
  if (formatString.includes("DOLLAR")) return d3.format(formatString.replace("DOLLAR", "$").replace(".", ",.") + "f");
  else if (formatString.includes("COMMA")) return d3.format(formatString.replace("COMMA", "").replace(".", ",.") + "f");
  else if (formatString.includes("F")) return d3.format(formatString.replace("F", "") + "f");
  else if (formatString.includes("BEST")) return d3.format(formatString.replace("BEST", "") + "f");
  else if (formatString.includes("PERCENT")) return d3.format(formatString.replace("PERCENT", "").replace(".", ",.") + "%");
  return d3.format("");
}

function legendDeselectAll() {
  SELECTED_CATEGORY = null;
  LEG.groupSelection.selectAll(".g-legend-entry").classed("selected", false);
  d3.selectAll(".data-path").transition("select").duration(HOVER_TRANS_TIME).attr("fill-opacity", OPACITY.fill.default).attr("stroke-opacity", OPACITY.stroke.default);
  d3.selectAll("[class*='data-point-']").transition("select").duration(HOVER_TRANS_TIME).attr("fill-opacity", OPACITY.stroke.default);
}

function legendSelect(event, datum) {
  SELECTED_CATEGORY = datum.key;
  event.stopPropagation(); 
  
  LEG.groupSelection.selectAll(".g-legend-entry").classed("selected", false);
  d3.selectAll(".data-path").transition("select").duration(HOVER_TRANS_TIME).filter(d => d.key !== datum.key).attr("fill-opacity", OPACITY.fill.unfocus).attr("stroke-opacity", OPACITY.stroke.unfocus);
  d3.selectAll("[class*='data-point-']").transition("select").duration(HOVER_TRANS_TIME).filter(d => d.key !== datum.key).attr("fill-opacity", OPACITY.stroke.unfocus);
  
  d3.select(event.currentTarget).classed("selected", true); 
  d3.select("#path-" + datum.id).moveToFront().transition("select").duration(HOVER_TRANS_TIME).attr("fill-opacity", OPACITY.fill.focus).attr("stroke-opacity", OPACITY.stroke.focus);
  d3.selectAll(".data-point-" + datum.id).transition("select").duration(HOVER_TRANS_TIME).attr("fill-opacity", OPACITY.stroke.focus);
}

function xTween(startRadius, endRadius, startAngle, endAngle) {
  const interpolateRadius = d3.interpolate(startRadius, endRadius);
  const interpolateAngle = d3.interpolate(startAngle, endAngle);
  return t => interpolateRadius(t) * Math.sin(interpolateAngle(t));
}

function yTween(startRadius, endRadius, startAngle, endAngle) {
  const interpolateRadius = d3.interpolate(startRadius, endRadius);
  const interpolateAngle = d3.interpolate(startAngle, endAngle);
  return t => -interpolateRadius(t) * Math.cos(interpolateAngle(t));
}

</script>

</body>
</html>
